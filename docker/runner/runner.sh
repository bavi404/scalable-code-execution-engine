#!/bin/bash
#
# Code Execution Runner Script
# Runs inside Docker container to execute user code safely
#
# Environment Variables:
#   TIME_LIMIT    - Maximum execution time in milliseconds
#   MEMORY_LIMIT  - Maximum memory in KB
#   LANGUAGE      - Programming language
#   RUN_CMD       - Command to run the code
#   COMPILE_CMD   - Optional compilation command
#
# Output: JSON result to stdout

set -o pipefail

# Configuration
WORKSPACE="/workspace"
RESULT_FILE="${WORKSPACE}/result.json"
TIME_LIMIT_MS="${TIME_LIMIT:-5000}"
MEMORY_LIMIT_KB="${MEMORY_LIMIT:-262144}"

# Convert time limit to seconds (with ceiling)
TIME_LIMIT_SEC=$(( (TIME_LIMIT_MS + 999) / 1000 ))

# Track timing
START_TIME_NS=$(date +%s%N)

# Initialize result JSON
init_result() {
    cat > "${RESULT_FILE}" << 'EOF'
{"success":false,"output":"","error":"Initialization failed","exitCode":1,"executionTimeMs":0,"memoryUsedKb":0}
EOF
}

# Calculate elapsed time in milliseconds
get_elapsed_ms() {
    local end_ns=$(date +%s%N)
    echo $(( (end_ns - START_TIME_NS) / 1000000 ))
}

# Get peak memory usage (Linux cgroups v2)
get_memory_kb() {
    local mem_bytes=0
    
    # Try cgroups v2
    if [ -f /sys/fs/cgroup/memory.peak ]; then
        mem_bytes=$(cat /sys/fs/cgroup/memory.peak 2>/dev/null || echo 0)
    # Try cgroups v1
    elif [ -f /sys/fs/cgroup/memory/memory.max_usage_in_bytes ]; then
        mem_bytes=$(cat /sys/fs/cgroup/memory/memory.max_usage_in_bytes 2>/dev/null || echo 0)
    fi
    
    echo $(( mem_bytes / 1024 ))
}

# Escape string for JSON
json_escape() {
    local str="$1"
    # Escape backslashes, quotes, and control characters
    str="${str//\\/\\\\}"
    str="${str//\"/\\\"}"
    str="${str//$'\n'/\\n}"
    str="${str//$'\r'/\\r}"
    str="${str//$'\t'/\\t}"
    printf '%s' "$str"
}

# Output JSON result
output_result() {
    local success="$1"
    local exit_code="$2"
    local output="$3"
    local error="$4"
    local passed_tests="${5:-0}"
    local total_tests="${6:-0}"
    
    local elapsed_ms=$(get_elapsed_ms)
    local memory_kb=$(get_memory_kb)
    
    # Escape output and error for JSON
    local escaped_output=$(json_escape "$output")
    local escaped_error=$(json_escape "$error")
    
    # Truncate very long outputs (max 100KB)
    if [ ${#escaped_output} -gt 102400 ]; then
        escaped_output="${escaped_output:0:102400}...[truncated]"
    fi
    if [ ${#escaped_error} -gt 102400 ]; then
        escaped_error="${escaped_error:0:102400}...[truncated]"
    fi
    
    cat > "${RESULT_FILE}" << EOF
{
  "success": ${success},
  "output": "${escaped_output}",
  "error": "${escaped_error}",
  "exitCode": ${exit_code},
  "executionTimeMs": ${elapsed_ms},
  "memoryUsedKb": ${memory_kb},
  "passedTests": ${passed_tests},
  "totalTests": ${total_tests}
}
EOF

    # Output to stdout for container logs
    cat "${RESULT_FILE}"
}

# Handle timeout signal
handle_timeout() {
    output_result "false" "124" "" "Time Limit Exceeded (${TIME_LIMIT_MS}ms)"
    exit 124
}

# Handle errors
handle_error() {
    local exit_code=$?
    local error_msg="$1"
    output_result "false" "${exit_code}" "" "${error_msg}"
    exit ${exit_code}
}

# Set up signal handlers
trap handle_timeout SIGTERM SIGALRM
trap 'handle_error "Execution interrupted"' SIGINT

# Initialize
init_result

# Change to workspace
cd "${WORKSPACE}" || handle_error "Cannot access workspace"

# Check if runner config exists (generated by docker-executor)
if [ -f "${WORKSPACE}/.runner_config" ]; then
    source "${WORKSPACE}/.runner_config"
fi

# ============================================
# COMPILATION PHASE (if needed)
# ============================================

if [ -n "${COMPILE_CMD}" ]; then
    echo "[Runner] Compiling..." >&2
    
    COMPILE_OUTPUT=$(timeout "${TIME_LIMIT_SEC}s" ${COMPILE_CMD} 2>&1)
    COMPILE_EXIT=$?
    
    if [ ${COMPILE_EXIT} -ne 0 ]; then
        if [ ${COMPILE_EXIT} -eq 124 ]; then
            output_result "false" "124" "" "Compilation Timeout"
        else
            output_result "false" "${COMPILE_EXIT}" "" "Compilation Error:\n${COMPILE_OUTPUT}"
        fi
        exit ${COMPILE_EXIT}
    fi
    
    echo "[Runner] Compilation successful" >&2
fi

# ============================================
# EXECUTION PHASE
# ============================================

echo "[Runner] Executing..." >&2

# Run with timeout and capture output
EXEC_OUTPUT=$(timeout "${TIME_LIMIT_SEC}s" ${RUN_CMD} 2>&1)
EXEC_EXIT=$?

echo "[Runner] Execution finished with exit code: ${EXEC_EXIT}" >&2

# Handle result
if [ ${EXEC_EXIT} -eq 124 ]; then
    # Timeout
    output_result "false" "124" "${EXEC_OUTPUT}" "Time Limit Exceeded (${TIME_LIMIT_MS}ms)"
    exit 124
elif [ ${EXEC_EXIT} -ne 0 ]; then
    # Runtime error
    output_result "false" "${EXEC_EXIT}" "" "Runtime Error (exit code ${EXEC_EXIT}):\n${EXEC_OUTPUT}"
    exit ${EXEC_EXIT}
else
    # Success
    output_result "true" "0" "${EXEC_OUTPUT}" ""
    exit 0
fi

